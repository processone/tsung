#!/usr/bin/perl -w
# -*- Mode: CPerl -*-
#
#  This code was developped by IDEALX (http://IDEALX.org/) and
#  contributors (their names can be found in the CONTRIBUTORS file).
#  Copyright (C) 2000-2004 IDEALX
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Version: $Id$

# purpose: quick and dirty ugly hack to compute stats and plots graph
# given a (set of) log file(s)  from the IDX-Tsunami tool.


use strict;
use Getopt::Long;
use vars qw ($help @files $verbose $debug $plot $extra $version $stats $template_dir $html $template_dir);
my $tagvsn = '%VERSION%';

GetOptions( "help",\$help,
			"verbose",\$verbose,
			"debug",\$debug,
			"stats=s",\$stats,
			"version",\$version,
			"plot",\$plot,
			"tdir",\$template_dir,
			"html",\$html,
			"extra",\$extra
		  );

&usage if $help or $Getopt::Long::error or not $stats;
&version if $version;

my $maxval;
my $category;

unless ($template_dir) {
    if (-d "$ENV{HOME}/.idx-tsunami/templates/") {
        $template_dir = "$ENV{HOME}/.idx-tsunami/templates/";
    } elsif (-d "/usr/share/idx-tsunami/templates") {
        $template_dir = "/usr/share/idx-tsunami/templates";
    }
}

my $datadir = "data"; # all data files are created in this subdirectory
my $imgdir  = "images"; # all data files are created in this subdirectory
my $gplotdir = "gnuplot"; # all data files are created in this subdirectory
my $http; # true if http. add status code graphs in the HTML output

foreach my $dir ($datadir, $imgdir, $gplotdir) {
    unless (-d $dir) {
        print "creating subdirectory $dir \n";
        mkdir "$dir" or die "can't create directory $dir";
    }
}

my $gnuplot = "gnuplot >> gnuplot.log 2>&1";

&parse_stats_file($stats);
&html_report() if $html;

# plot stats from file
sub plot_stats {
	# args:
	my $title     = shift; # arrayref contaning data titles
	my $datatype  = shift; # type of data (added in filenames)
	my $timestamp = shift;
	my $files     = shift; # arrayref contaning data files
	my $ylabel    = shift;

	# local var
	my $style       = "linespoint"; # TODO: can be override in option
	my $legend_loc  = "key right top"; # TODO: can be override in option
	my $output_type;
	my $filename; # temporary var
	my $thumbnail_size = 0.5;

	$datatype = "unknown" unless $datatype;
	open(GP,">$gplotdir/graphes-$datatype.gplot") or die "can't open graphes-$datatype.gplot: $!";
	select GP;
    foreach my $output_ext ("ps", "png") {
        if ($output_ext eq "png") {
            $output_type = "png";
        } elsif ($output_ext eq "ps") {
            $output_type = "postscript color ";
        }
        # gnuplot styles and options
        print "set size $thumbnail_size,$thumbnail_size\n" if ($output_ext eq "png");
        print "set data style $style\n";
        print "set terminal $output_type\n";
        print "set grid\n";
        my $d; # temporary var (title)
        foreach $d (0..$#{$title}) {
            # gnuplot headings
            print "set output \"$imgdir/graphes-$datatype-@{$title}[$d].$output_ext\"\n";
            print "set title \" @{$title}[$d]\"\n";
            if ($timestamp) {
                print "set xlabel \"unit = $timestamp sec \"\n";
            } else {
                print "set xlabel \"unit = sec \"\n";
            }
            print "set ylabel \"".$ylabel->[$d]."\"\n" if $ylabel->[$d];
            print "show title\n";
            print "set $legend_loc\n";
            print "plot ";
            foreach $filename (@{$files}) {
                print " \"$datadir/$filename\" using ";
                # if $timestamp isn't defined, use the first column as timestamp
                if ($timestamp) {
                    print $d+1 ;
                } else {
                    print " 1:" .($d+2);
                }
                print " title \"$filename\"" ;
                print "," unless ($filename eq @{$files}[$#{$files}]); # unless last occurence
            }
            print "\n"; # plot done
        }
    }
	close GP;
	system("$gnuplot $gplotdir/graphes-$datatype.gplot");
}

sub max {
	my $value   = shift;
	my $oldvalue= shift;
	return $value unless $oldvalue;
	return $value if $oldvalue < $value;
	return $oldvalue;
}

sub min {
	my $value   = shift;
	my $oldvalue= shift;
	return $value unless $oldvalue;
	return $value if $oldvalue > $value;
	return $oldvalue;
}

sub parse_stats_file {
	my $file = shift;
	my $data;
	my $timestamp;
	my $first_timestamp =0;
	my $first_interval =0;
	my $interval;

	open (FILE,"<$file") or die "Can't open $file $!";
	while (<FILE>) {
		if (/^stats: (\S+)\s+(.*)$/) {
			my $type = $1;
			my $values = $2;
			$type =~ s/page_resptime/page/g;
			$type =~ s/response_time/request/g;
			my ($rate,$mean) = split(/\s+/,$values);
			if ($interval) {
				$rate /= $interval;
				$maxval->{'rate'}->{$type} = &max($rate, $maxval->{'rate'}->{$type});
				$maxval->{'mean'}->{$type} = &max($mean, $maxval->{'mean'}->{$type});
				$maxval->{'minmean'}->{$type} = &min($mean, $maxval->{'minmean'}->{$type}) if $rate;
			}
            if ($type =~ /^cpu:/ ) {
                $category->{$type} = "os_mon_cpu";
            } elsif ($type =~ /^freemem:/) {
                $category->{$type} = "free";
            } elsif ($type =~ /^\w{4}packets:/) {
                $category->{$type} = "os_mon_packets";
            } elsif ($type =~ /^\d+$/) {
                $category->{$type} = "http_status";
            } elsif ($type eq "request" or $type eq "page" or $type eq "session" or  $type eq "connect") {
                $category->{$type} = "stats";
            } elsif ($type =~ /^tr_/ or $type eq "page") {
                $category->{$type} = "transaction";
            } elsif ($type eq "size") {
                $category->{$type} = "network";
            } elsif ($type ne "users") {
                $category->{$type} = "count";
            }
			push @{$data->{$type}}, $timestamp . " ". $values;
		} elsif (/^\# stats:\s+dump at\s+(\d+)/) {
			$first_timestamp= $1 unless $first_timestamp;
			$interval = ($timestamp) ? $timestamp : 0; # keep previous value
			$timestamp = $1 - $first_timestamp;
			$interval = $timestamp-$interval;
			$first_interval= $interval if $interval and not $first_interval;
		}
	}
	close FILE;
    unless ($html) {
        foreach my $key (sort keys %{$maxval->{'rate'}}) {
            if ($key =~ /\d+/ or $key eq 'size') {
                printf "Total $key = %7.2f\n", $maxval->{'mean'}->{$key};
            } else {
                printf "Mean  $key (max sample) = %7.2f\n", $maxval->{'mean'}->{$key};
            }
            printf "Rate  $key (max sample) = %7.2f\n",$maxval->{'rate'}->{$key};
        }
    }
	my @time;
	my @tps;
	my @code;
    my %extra_info = ();
	my @connect;
	my @size;
	my @users;
	my @users_rate;
	my @transactions;
	my $key;
    if ($interval != $first_interval) {
        print "warn, last interval ($interval) not equal to the first, use the first one ($first_interval)\n";
        $interval=$first_interval;
    }
	my @col = ("rate","mean","stdvar","max_sample","min_sample");
	my @colcount = ("rate","total");
	my @colusers = ("simultaneous","maximum_simultaneous");
	foreach $key (keys %{$data}) {
        $key =~ s/\'//g;
		open (TYPE, "> $datadir/$key.txt") or die "$!";
		foreach my $data (@{$data->{$key}}) {
			if (($key !~ /^users$/ and $key !~ /^size$/) and $interval) {#
				my @tmp;
				my $time;
				($time, $data, @tmp) = split(/\s/,$data);
				$data /= $interval;
				$data = "$time $data @tmp";
			} elsif ($key =~ /size/) { # bits instead of bytes
				my ($time, @tmp) = split(/\s/,$data);
				@tmp = map {$_*8/(1024*$interval) } @tmp; # kb/s instead of Bytes/s
				$data = "$time @tmp";
			}
			print TYPE $data ."\n";
		}
		if ($key eq "session" or $key eq "reconnect" or $key eq "connect") {
			push @connect, "$key.txt";
		} elsif ($key eq "size") {
			push @size, "$key.txt";
		} elsif ($key =~ /^users$/) {
			push @users, "$key.txt";
		} elsif ($key =~ /users/) {
			push @users_rate, "$key.txt";
		} elsif ($key =~ /request$/) {
			push @tps, "$key.txt";
		} elsif ($key =~ /^tr_/ or $key eq "page") {
			push @transactions, "$key.txt";
		} elsif ($key =~ /^\d+$/) {
            $http = 1;
			push @code, "$key.txt";
		} elsif ($key =~ /^(\S+)?:\S+?@\S+$/) {
            my $key_short_name = $1;
            push(@{$extra_info{$key_short_name}}, "$key.txt");
		} else {
			push @time, "$key.txt";
		}
		close TYPE;
	}
	plot_stats(\@col,"Session",undef,\@connect,["sessions/sec"]) if $plot;
	plot_stats(\@colcount,"HTTP_CODE",undef,\@code,["number/sec","total"]) if $plot;
	plot_stats(\@col,"Perfs",undef,\@tps,["rate/sec","msec"]) if $plot;
	plot_stats(\@col,"Transactions",undef,\@transactions,["rate/sec","msec"]) if $plot;
	plot_stats(\@colcount,"Event",undef,\@time,["rate/sec","msec"]) if $plot;
	plot_stats(\@colusers,"Users",undef,\@users,["connected users", "total"]) if $plot;
	plot_stats(\@colcount,"Users_Arrival",undef,\@users_rate,["number of users/sec", "total"]) if $plot;
	plot_stats(\@colcount,"Size",undef,\@size,["Kbits/sec","total Kbits"]) if $plot;

    # Generate graphes for extra indicators (os_mon for example)
	if ($plot and $extra) {
        print STDOUT "Generation os_mon graphs\n" if $verbose;
 	  foreach my $key (sort keys %extra_info) {
          my $pos = index($key,":");
          plot_stats(\@col, $key, undef, \@{$extra_info{$key}}, [$key]);
      }
  }
}

sub html_report {
    require Template;
    my $titre     = 'IDX-Tsunami ';
    my $version   = $tagvsn;
    my $contact   = "nicolas.niclausse\@IDEALX.com";
    my $output   = 'index.html';

    my $tt = Template->new({
                            INCLUDE_PATH => $template_dir,
                            PRE_CHOMP    => 1,
                            INTERPOLATE  => 1,
                           }) or die "Template error $!";
    my $xml_conf;
    opendir (DIR, ".") or warn "can't open directory .";
    while (my $file = readdir (DIR) ) {
        if ($file =~ /.xml$/) {
            $xml_conf= $file;
        }
    }
    $maxval->{rate}->{size} = sprintf("%.2f",$maxval->{rate}->{size}*8/1024);
    $maxval->{mean}->{size} = sprintf("%.2f",$maxval->{mean}->{size}/(1024*1024));
    my $vars =
        {
         version     => $version,
         os_mon      => $extra,
         title       => $titre,
         http        => $http,
         stats_subtitle => "Stats Report ",
         graph_subtitle => "Graphs Report ",
         contact     => $contact,
         data        => $maxval,
         cat_data    => $category,
         conf        => $xml_conf
        };
    $tt->process("report.thtml", $vars, "report.html") or die $tt->error(), "\n";
    $vars =
        {
         version     => $version,
         os_mon      => $extra,
         http        => $http,
         title       => $titre,
         stats_subtitle => "Stats Report ",
         graph_subtitle => "Graphs Report ",
         contact     => $contact,
         conf        => $xml_conf
        };
    $tt->process("graph.thtml", $vars, "graph.html") or die $tt->error(), "\n";
}


sub usage {
	print "this script is part of IDX-TSUNAMI version $tagvsn,
Copyright (C) 2001 IDEALX (http://IDEALX.org/)\n\n";
	print "IDX-TSUNAMI comes with ABSOLUTELY NO WARRANTY; This is free software, and
ou are welcome to redistribute it under certain conditions
type `idx-tsunami.pl --version` for details.\n\n";

    print "Usage: $0 [<options>]\n","Available options:\n\t",
    "[--help] (this help text)\n\t",
    "[--verbose] (print all messages)\n\t",
    "[--debug] (print receive without send messages)\n\t",
    "[--plot]  (make postcripts graphics using gnuplot)\n\t",
    "[--extra  (generate graphics from extra cluster data (os monitor, etc)\n\t",
    "[--stats <file>] (stats file to analyse)\n\t";
	exit;
	}

sub	affiche() {
	my $name = shift;
	my $value = shift;
	return sprintf "#%7s = %.3f",$name,$value;
}

sub version {
print "this script is part of IDX-TSUNAMI version $tagvsn

Written by Nicolas Niclausse and Jean François Lecomte

Copyright (C) 2001-2004 IDEALX (http://IDEALX.org/)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (see COPYING); if not, write to the 
Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
Boston, MA 02111-1307, USA.";
exit;
}
